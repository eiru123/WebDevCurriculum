* Quest 14. Hello, MySQL
    * RDBMS
        * 2차원 표 형식으로 데이터를 관리하는 데이터베이스, 현재 가장 주류. 사람들이 자연스럽고 직관적으로 이해하기 쉬운 형식으로 데이터 관리를 할 수 있다. 관계형 데이터베이스를 실현하기 위한 소프트웨어.
    * MySQL
        * 오픈소스 데이터베이스. 관계형 데이터베이스 관리 시스텝이다. 위의 RDBMS의 특징을 가진다. MySQL 서버는 클라이언트/서버 또는 임베디드 시스템에서 사용할 수 있다. 다양한 운영체제에서 사용가능하다.
    * 각종 쿼리
        * 데이터베이스 생성 (create): 
        ```
        CREATE database 데이터베이스명;
        ```
        * 데이터베이스 삭제 (drop):
        ```
        DROP database 데이터베이스명;
        ```
        * table 생성 (create): 
        ```
        CREATE TABLE 테이블명(
            열이름 타입 [NULL, 일반 키 설정 등],
        );
        ```
        * table 삭제 (drop):
        ```
        DROP table 테이블명;
        ```
        * table 목록 보기 (show):
        ```
        SHOW tables;
        ```
        * data 삽입 (insert):
        ```
        INSERT INTO 테이블명 [(열 이름)] VALUES (대응되는 값들);
        ```
        * data 수정 (update):
        ```
        UPDATE 테이블명 SET 칼럼=값,... [WHERE 조건식];
        ```
        * data 삭제 (delete):
        ```
        DELETE FROM 테이블명; (모든 데이터 삭제)
        DELETE FROM 테이블명 [WHERE]; (where 조건에 해당하는 열들 삭제)
        ```
        * data 교체 (REPLACE):
        삽입하려는 레코드의 기본키가 기존에 있으면 기존 레코드를 삭제하고 새로운 레코드를 삽입힌다.
        기존레코드가 없다면 단순히 삽입되기만 한다. 사용 방법은 INSERT와 동일하다.
        ```
        REPLACE INTO 테이블명 [(열이름)] VALUES (대응되는 값들);
        ``` 
        * data 조회(SELECT):
        ```
        SELECT 식 또는 필드 FROM 테이블명 [WHERE 조건] [GROUP BY [HAVING]] [ORDER BY 필드] [LIMIT 행수]
        ```호
    * Hash
        * hash란 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 것.
        * 단방향성: 원래의 데이터를 해시 함수로 얻어진 결과값은 다시 원래의 정보를 알아내기 어렵다. 따라서 password로 많이 이용된다.
        * 민감성: 원정보에 아주 조금의 변화라도 발생하면, 해쉬값은 전혀 다른 값이 된다. 결국 원정보가 같지 않다면 동일한 해시값을 얻을 수 없다.
        * 해시값의 모양: 정보의 양과 종류에 상괍없이 항상 일정한 길이로 산출된 임의의 알파벳과 숫자의 조합을 갖는다.
        * 해시 함수는 키를 사용하지 않으므로 같은 입력에 대해서는 항상 같은 출력이 나온다. 이러한 해시함수를 사용하는 목적은 메시지의 오류나 변조를 탐지할 수 있는 무결성을 제공하기 위해 사용된다.
    * SHA256
        * SHA(Secure Hash Algorithm)은 NIST에 의해 공표된 표준 해시 알고리즘으로 sw 시장 전반에서 전세계적으로 가장 많이 사용되고 있다.
        * SHA-2 계열 중에서 가장 많이 사용된다.
        * 256비트로 구성되어 64자리 문자열을 반환한다. 
* CheckList
    * RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?
        * 해당 배열에 관련된 테이블을 설계한 후 거기에 저장한다.
    * RDBMS 테이블의 정규화는 무엇인가요?
        * 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되고, 저장공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신 이상이 발생한다. 동일한 정보를 한 릴레이션에는 변경하고 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게된다. 이를 해결하기 위해 정규화를 한다. 중복을 최소화하기 위해 데이터를 구조화하는 작업.
        * 갱신 이상이란?
            1. 삽입 이상: 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제.
            1. 삭제 이상: 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로써 원치 않는 데이터 손실 발생 가능.
            1. 갱신 이상: 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제.
        * 종류
            1. 제 1정규형: 애트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 다중값 애트리뷰트, 중첩 릴레이션등을 허용하지 않는다.
            1. 제 2정규형: 제 1정규형을 만족하면서 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속이면 제 2정규형을 만족한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.
            1. 제 3정규형: 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3정규형을 만족한다고 본다. 이행 함수적 종속이란 X->Y, Y->Z의 경우에 의해서 추론될 수 있는 X->Y의 종속관계를 말한다.
            1. BCNF(Boyce-Codd)정규형: 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용. 제 3정규형을 보완.
    * MySQL 엔진에는 어떤 것들이 있나요?
        1. InnoDB: default 스토리지 엔진 transaction-safe하며, 커밋과 롤백, 그리고 데이터 복구 기능을 제공하므로 데이터를 효과적으로 보호할 수 있다. 기본적으로 row-level locking 제공. 외래키 제약을 제공하여 데이터 무결성을 보장한다.
        1. MyISAM: 트랜잭션을 지원하지 않고 table-level locking을 제공. 따라서 multi-thread환경에서 성능이 저하 될 수 있다. 특정 세션이 테이블을 변경하는 동안 테이블 단위로 lock이 잡힌다.
        1. Archive: '로그 수집'에 적합한 엔진. 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장되기 때문에 row-level locking이 가능. 다만 한 번 insert 된 데이터는 update, delete를 사용할 수 없다.
    * RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
        * RDBMS에서 검색속도를 높이기 위해 사용하는 하나의 기술. 해당 table의 컬럼을 색인화하여 검색시 해당 table의 레코드를 full scan하는게 아니라 색인화 되어 있는 index파일을 검색하여 검색속도를 빠르게 한다. 이런 index는 트리 구조로 색인화한다. RDBMS에서 사용하는 index는 balance search tree를 사용한다. 테이블 생성시 만들어진 MYI파일에 색인화된 컬럼을 저장한다. 만약 색인화된 컬럼이 없다면 MYI 파일은 비어있게 된다.
        * index의 장점
            1. 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
            1. 질의나 보고서에서 그룹화 작업의 속도를 향상시킨다.
            1. index를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
            1. 테이블의 기본 키는 자동으로 인덱스 된다.
            1. 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드도 있다.
            1. 여러 필드로 이루어진 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할 수 있다.
        * index의 단점
            1. 인덱스를 만들면 .mdb 파일 크기가 늘어난다.
            1. 여러 사용자 응용 프로그램에서의 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
            1. 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다.
            1. 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
            1. 데이터 변경 작업이 자주 일어날 경우에 인덱스를 재작성해야 할 필요가 있다.
            (출처): https://lalwr.blogspot.com/2016/02/db-index.html

    * DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까?
        * 사용자의 암호를 평문으로 저장하지 않고 DB 내에 암호화 함수를 사용하여 저장했다고 하자. 이 때 사용된 암호화 함수는 SHA()라고 가정한다면 해쉬 함수는 위의 정리에 나와있듯이 같은 값에는 항상 같은 해쉬값을 반환한다. 따라서 사용자의 패스워드가 올바르게 입력됐다면 같은 해쉬 함수를 사용하여 복호화한  후 비교했을 때 같다면 제대로 된 비밀번호를 입력했다는 것이 되고 그것이 아니라면 다르느 비밀번호를 입력했다는 것이 된다. 따라서 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능하다.
* SQL이란?
    * Structured Query Language
    * 관계형 데이터베이스가 데이터를 조작하기 위한 언어.
* 스토리지 엔진
    * MySQL 엔진은 요청된 SQL문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진을 이용. MySQL 서버에서 MySQL 엔진은 하나만 사용할 수 있지만 스토리지 엔진은 여러 개 사용할 수 있다. 
* 핸들러
    * MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 꼭 통해야 한다.
* 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되느지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 하는것이 중요하다.
* 쿼리 캐시: 쿼리의 결과를 저장해둔다.

* table 
    * users table:
    ```
    CREATE TABLE users(
        userId VARCHAR(32) NOT NULL,
        password VARCHAR(64) NOT NULL,
        focusedTab VARCHAR(32),
        cursorPos MEDIUMINT UNSIGNED,
        PRIMARY KEY(userId)
    );
    ```
    * files table:
    ```
    CREATE TABLE files(
        userId VARCHAR(32) NOT NULL,
        filename VARCHAR(32) NOT NULL,
        content MEDIUMTEXT,
        open TINYINT(1),
        PRIMARY KEY(userId, filename).
        FOREIGN KEY(userId) REFERENCES users(userId) ON UPDATE CASCADE ON DELETE CASCADE
    );